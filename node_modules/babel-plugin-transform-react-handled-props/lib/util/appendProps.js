'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _createExpressions = require('./createExpressions');

var _isReactComponent = require('./isReactComponent');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var findTarget = function findTarget(path) {
  if (t.isArrowFunctionExpression(path) || t.isFunctionExpression(path)) {
    var declarationPath = path.findParent(function (parentPath) {
      return t.isVariableDeclaration(parentPath);
    });

    return findTarget(declarationPath);
  }

  if (t.isExportDeclaration(path.parent)) return path.findParent(function (parentPath) {
    return t.isExportDeclaration(parentPath);
  });
  if (t.isExpression(path)) return path.findParent(function (parentPath) {
    return t.isDeclaration(parentPath);
  });

  return path;
};

var pushToClassBody = function pushToClassBody(_ref, expression) {
  var body = _ref.node.body.body;
  return body.push(expression);
};

var insertAfterPath = function insertAfterPath(_ref2) {
  var identifier = _ref2.identifier,
      path = _ref2.path,
      props = _ref2.props;

  if ((0, _isReactComponent.isClass)(path)) {
    pushToClassBody(path, (0, _createExpressions.createClassProperty)(props));
    return;
  }

  findTarget(path).insertAfter((0, _createExpressions.createFunctionProperty)(identifier, props));
};

var insertEntries = function insertEntries(entries) {
  return _lodash2.default.forEach(entries, insertAfterPath);
};

exports.default = insertEntries;